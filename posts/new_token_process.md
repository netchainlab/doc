---
layout: base-layout.njk
---

# New token development process<a name=""></a>

Процесс разработки нового токена

## TOC<a name="toc"></a>

- [New token development process](#new-token-development-process)
  - [TOC](#toc)
  - [Terms and definitions](#terms-and-definitions)
  - [Tokens, basic concepts](#tokens-basic-concepts)
    - [Assets](#assets)
    - [Chaincodes](#chaincodes)
    - [Token issuance](#token-issuance)
    - [Token operations](#token-operations)
    - [Token redemption](#token-redemption)
  - [Architecture elements](#architecture-elements)
    - [Channels](#channels)
    - [Atomic swap](#atomic-swap)
    - [Batching](#batching)
  - [Chaincodes](#chaincodes-1)
    - [Common description](#common-description)
    - [BaseContract and BaseToken](#basecontract-and-basetoken)
  - [IndustrialToken](#industrialtoken)
  - [Appendix 1. BaseContract code](#appendix-1-basecontract-code)
  - [Appendix 2. BaseToken code](#appendix-2-basetoken-code)
  - [Appendix 3. IndustrialToken code](#appendix-3-industrialtoken-code)

## Terms and definitions<a name="terms-and-definitions"></a>

Таблица 1. Список основных технических определений и акронимов

| Акроним | Определение (англ) | Определение (рус) |
| --- | --- | --- |
| 2FA/ MFA | Two factor authentication/ multi-factor authentication | Двухфакторная аутентификация/многофакторная аутентификация |
| ABC | Asset-backed coin | Монета, обеспеченная активами |
| ACL | (Access control list) A list of access control entries | Список записей контроля доступа |
| AML | Anti-money laundering | Борьба с отмыванием денег |
| API | Application programming interface | Интерфейс прикладного программирования |
| BFT | Byzantine fault tolerant | Byzantine отказоустойчивость |
| CFT | Crash fault tolerant | Crash отказоустойчивость |
| CI/CD | Continuous integration/continuous delivery | Непрерывная интеграция/непрерывная поставка |
| ЦП | Central processing unit | Центральный процессор |
| БД | Database | База данных |
| СУБД | Database management system | Система управления базами данных |
| DLT | Distributed ledger technology | Технология распределенного реестра |
| DNS | Domain name system | Система доменных имен |
| GCP | Google Cloud Platform | Google Cloud Platform |
| HLF | Hyperledger Fabric | Hyperledger Fabric |
| HSM | Hardware security module | Аппаратный модуль безопасности |
| ICS | Internal control system | Система внутреннего контроля |
| KPI | Key performance indicator | Ключевой показатель эффективности |
| KYB | Know-Your-Business | Know-Your-Business |
| MPC | Multiparty computation | Многосторонние вычисления |
| MSP | Membership service provider | Поставщик услуг членства |
| OSI | Open Systems Interconnection model | Модель взаимодействия открытых систем |
| OSN | Ordering service node | Узел обслуживания заказов |
| OTF | Organized trading facility | Организованная торговая площадка |
| PKI | Public key infrastructure | ключей |
| RFQ | Request for quotation | Запрос |
| SDK | Software development kit | Комплект |
| SDLC | Software development life cycle | Жизненный цикл разработки программного обеспечения |
| SIEM | Security information and event management | Информация о безопасности и управление событиями ent |
| TPS | Transactions per second | Транзакции в секунду |
| tx | Transaction | Транзакция |
| VM | Virtual machine | Виртуальная машина |
| VP-Consensus | Validated and Provable Consensus | Проверенный и доказуемый консенсус |
| VPC | Virtual private cloud | Виртуальное частное облако |
| VPN | Virtual private network | Виртуальная частная сеть |
| VT | Validation token | Токен проверки |
| WAL | Write ahead log | Упреждающая запись в журнал |

Таблица 2. Термины

| Термин | Определение |
| --- | --- |
| ABC | Токен, обеспеченный несколькими активами. |
| AML | Процедуры, направленные на предотвращение маскировки незаконно полученных средств под законный доход. |
| API | Четко определенные методы, набор классов, процедур, функций, структур и констант. |
| Актив | Информационный объект, для которого Система Блокчейн обеспечивает запись и обработку. В Hyperledger Fabric актив представляет собой набор записей об этом информационном объекте, размещенном в реестре. |
| Атомарный своп | Обмен различными токенами, выпущенными на платформе, осуществляется посредством атомарного свопа из-за ограничений во взаимодействии двух разных каналов. |
| Платформа Atomyze, Платформа, Система | Вся экосистема Atomyze. |
| Базовый актив | Актив, торгуемый в выбранной паре активов, т.е. валюта, в которой выражена сумма сделки, актив, полученный покупателем от продавца по сделке в выбранной паре активов. |
| BFT алгоритм консенсуса | Алгоритм консенсуса, способный обрабатывать ряд византийских ошибок (byzantine faults) в распределенной сети среди ограниченного числа участников. Алгоритм задает порядок коммуникации между валидаторами в сети, чтобы обеспечить целостность и правильность истории транзакций. |
| Блокчейн (Blockchain) | Неизменный распределенный реестр, поддерживаемый сетью узлов. Как только протокол консенсуса Blockchain подтверждает передачу активов между участниками сети, каждый узел записывает транзакцию. Записи операций по активам отсортированы по времени и сгруппированы в цепочку постоянных блоков. Каждый последующий блок записей транзакций содержит хэш, связывающий с предыдущим блоком. Записи транзакций может производить каждый из участников сети Блокчейн. Транзакции записываются в распределенный реестр с использованием чейнкодов — бизнес-логики обработки транзакций, согласованной и принятой всеми участниками сети.Технология блокчейн обеспечивает распространение общего журнала транзакций между участниками сети, чтобы участники могли быть уверены в неизменности и целостности журнала. Таким образом, участники могут быть уверены, что обработка одних и тех же транзакций с выбранными активами приведет к тому, что все участники получат одинаковый результат. |
| Блокчейн-канал | Специальный механизм на уровне архитектуры Hyperledger Fabric, обеспечивающий необходимый уровень конфиденциальности транзакций в сети Блокчейн и повышающий масштабируемость. Канал — это частная подсеть связи между конкретными участниками сети.Каждая частная подсеть представляет собой набор участников сети Блокчейн, образующих одноранговую сеть для поддержания логически унифицированного и физически распределенного реестра. Сделки, совершенные на общих активах участников канала с использованием чейнкодов, фиксируются в реестре. |
| Протокол консенсуса блокчейна | Системный процесс подтверждения транзакций между участниками сети Блокчейн, используемый для записи результатов транзакций в распределенный реестр. Участники сети договариваются и устанавливают общие для всех правила проверки транзакций. В рамках данного проекта правила проверки транзакций устанавливаются разработчиками Системы. Для достижения консенсуса участники должны согласиться с транзакцией и подтвердить ее, прежде чем она будет постоянно записана в распределенном реестре. Записанные транзакции неизменяемы и не могут быть удалены. Протокол консенсуса снижает риск мошеннических транзакций, поскольку фальсификация транзакций должна происходить одновременно на большинстве сетевых узлов. |
| Византийская ошибка | Состояние компьютерной системы, особенно распределенных вычислительных систем, при котором компоненты могут выйти из строя, а информация о том, вышел ли из строя компонент, неполная. |
| Чейнкод (Chaincode) | чейнкод в Hyperledger Fabric. |
| Валютный токен (CT) | Токен, обеспеченный валютой, стоимость одного токена соответствует одной единице валюты. |
| Распределенный реестр (Ledger) | Запись всех транзакций, обработанных сетью Blockchain и чейнкодами. Запись распространяется в том смысле, что она реплицируется и синхронизируется между всеми членами сети. Распределенный реестр фиксирует транзакции о состоянии активов участников в сети.Участники сети регулируют и соглашаются на основе консенсуса в отношении обновлений записей в реестре. Ни центральный регулирующий орган, ни сторонний посредник в процессе не участвуют. Каждая запись в распределенном реестре имеет временную метку и уникальную криптографическую подпись, что делает реестр проверяемой историей всех транзакций в сети. |
| Промышленный клиент | Покупатель ABC, подкрепленный контрактами на поставку товаров, необходимых для производственных процессов. |
| Промышленный токен (Industrial token) | Более широкий термин для плавающих непредоплаченных, предоплаченных и фиксированных ABC. |
| Инвестиционный клиент | Те, кто покупает, торгует и продает активы в инвестиционных целях. |
| Инвестиционный токен | Более широкий термин для распределенных, дробных, нераспределенных ABC. |
| Эмитент | Текущий или будущий владелец товара или любого другого актива, который хочет токенизировать свой актив, создав и выпустив ABC. |
| Генерация ключей | Процесс, в результате которого создается пара открытого и закрытого ключей. |
| Задержка | Время задержки между отправкой данных от клиента и их получением на сервере и наоборот. |
| Реестр | Последовательная, защищенная от несанкционированного доступа запись всех переходов между состояниями. |
| Сеть | Совокупность участников, которые взаимодействуют друг с другом, выполняя операции с активами. |
| Узел | Компьютер, участвующий в распределенной сети |
| Ордерер (Orderer) | Узел особого типа, который упорядочивает транзакции, группируя их в блоки, и подтверждает включение таких сформированных блоков в блокчейн. |
| OTF | Торговый модуль, который включает в себя разделы RFQ, стриминоа и BlockTrade, которые используются для торговли токенами на вторичном рынке. |
| Участник | Физическое или юридическое лицо, зарегистрированные в качестве пользователя на Платформе. |
| Частный канал | Блокчейн-канал с ограниченным доступом. |
| Закрытый ключ | Один из компонентов, используемых в асимметричной криптографии. Закрытый ключ должен быть известен только пользователю, и пользователь не должен раскрывать его другим лицам, поскольку он используется для авторизации действий пользователя. |
| ID продукта | Уникальный идентификатор для каждого токена. |
| Открытый ключ | Один из компонентов, используемых в асимметричной криптографии. Открытый ключ может быть открыт широкому кругу лиц, не опасаясь компрометации действий пользователя. Его может использовать кто угодно, чтобы убедиться, что действие выполнено пользователем. |
| Погашение (Redemption) | Процесс обмена токенов пользователя на базовый актив, который является безопасностью этого токена. |
| SDK | Набор средств разработки программного обеспечения в одном устанавливаемом пакете. |
| Подпись | Процесс формирования информационного объекта на основе закрытого ключа пользователя и самого объекта. Гарантирует, что пользователь авторизован для выполнения определенного действия. |
| Стриминг (Streaming) | Функция торговли, позволяющая участникам размещать предложения и указывать цену за одно из предопределенных количеств токенов. Участники могут принимать доступные предложения и заключать сделки. |
| Токен | Учетная единица, используемая для представления цифрового баланса в определенном активе. В терминах Hyperledger Fabric каждый токен реализован как отдельный чейнкод. Общий термин, описывающий все цифровые активы (обеспеченные и необеспеченные). |
| Трансфер (Transfer) | Процесс, в результате которого токены перемещаются из одного кошелька с ключом в другой. |
| TVE | Специальный модуль OTF, обеспечивающий соответствие заключенных на платформе сделок набору правил TVE. |
| Токен проверки (VT) | Не подлежащее погашению вознаграждение за услуги проверки. Позволяет участвовать в процессе управления проверкой. |
| Валидатор (Validator) | Доверенный объект (держатель токена проверки), который управляет узлами платформы Atomyze и выполняет проверку транзакций, зарегистрированных в сети Blockchain и записанных в блоках распределенного реестра. |
| Cостояние мира (World State) | База данных, в которой хранится кэш текущих значений набора состояний реестра. В контексте платформы Atomyze состояние мира хранит сведения о токенах вместе с транзакциями, ожидающими пакетной обработки |
| Пир | Узел валидации, который в рамках подтверждения транзакций осуществляет функционал по записи сформированных Ордерером блоков транзакций в реестр. Функции Пира и Эндорсера могут быть совмещены в одном Узле валидации. |
| Эндорсер | Узел валидации, который в рамках подтверждения транзакций осуществляет функционал по одобрению транзакций, который включает в себя проверку приватных ключей и балансов Кошельков, передачу транзакций ордерерам для формирования блоков (упорядочивания) транзакций. Функции пира и эндорсера могут быть совмещены в одном узле валидации |

## Tokens, basic concepts<a name="tokens-basic-concepts"></a>

### Assets<a name="assets"></a>

Активы (assets) — это объекты высокой стоимости, которые часто используются в качестве инвестиций и продаются. Активы могут быть материальными, что означает, что актив имеет физическую форму, или нематериальными, если они не имеют физической формы. Выпуск токенов, обеспеченных реальными активами, в том числе товарами и услугами, доступен для организаций, являющихся эмитентами на платформе, а покупка и продажа таких токенов доступна для широкого круга инвесторов и промышленных клиентов, являющихся участниками платформы.

Примеры материальных активов:
• Драгоценные металлы и камни: золото, серебро, бриллианты и др.
• Недвижимость: квартиры, автомобили и т.д.
• Фиатная валюта: различные мировые валюты.

Примеры нематериальных активов:
• Инструменты инвестирования: акции, облигации и др.
• Услуги: билеты, баллы лояльности, владения и т. д.

В токенизации активов есть несколько общих процессов. В большинстве вариантов использования токенизации активов реализуются описанные ниже процессы, хотя они могут отличаться в деталях.

### Chaincodes<a name="chaincodes"></a>

Каждый токен реализован в виде чейнкода, реализующего бизнес-логику операций с соответствующим цифровым активом.

За разработку чейнкода отвечает организация-эмитент. Саму разработку могут выполнять разные организации (например, Atomyze). После разработки код чейнкода технически проверяется платформой (на соответствие установленным правилам создания и управления каналом, принятыми политиками и требованиями безопасности), внешними аудиторами (на соответствие опубликованному тексту чейнкода). После прохождения аудитов создается канал, загружается и устанавливается код чейнкода.

Канал — это частная подсеть связи между конкретными участниками сети. Канал представляет собой набор участников сети Блокчейн, образующих одноранговую сеть для поддержания логически унифицированного и физически распределенного реестра. Конфиденциальность транзакций в канале обеспечивается специальным механизмом на уровне архитектуры Hyperledger Fabric. Сделки, совершенные на общих активах участников канала с использованием чейнкодов, фиксируются в реестре.

Вся ответственность за бизнес-логику, реализуемую чейнкодом, лежит на организации-эмитенте. При этом права на управление чейнкодом и его эксплуатацию реализуются через администрацию платформы.

Жизненный цикл токена включает следующие этапы:
• Выпуск токена (Token issuance)
• Продажа/покупка/трансфер токенов (Token operations)
• Выкуп токенов (Redemption)

Каждый этап характеризуется своими специфическими процессами. Некоторые процессы могут быть обязательными, другие - необязательными. Ниже представлено подробное описание каждого этапа.

### Token issuance<a name="token-issuance"></a>

Выпуск токена доступен для роли Эмитента в Платформе. Эмитент — юридическое лицо, которому необходимо пройти процедуру KYB и выполнить необходимые офф-лайн-процедуры.

Эмитент должен описать ключевые бизнес-процессы для оцифровываемого актива и указать функции, которые должны быть доступны на Платформе для этого актива. Затем Эмитент (или любая другая доверенная сторона, которая может выполнять эти действия) должен разработать чейнкод для этого актива.

Перед выпуском токена на платформе Эмитент публикует white paper токена, текст чейнкода для участников платформы, в котором описаны характеристики токена, конфиденциальность, правила выпуска, обращения, выкупа, политики передачи и другие особенности использования токенов.

Также выпуск токена может подразумевать обновление функциональных служб платформы (внутренняя часть) и пользовательских интерфейсов (внешняя часть).

Выпуску токена предшествует регистрация актива. Регистрация производится либо администрацией площадки, либо доверенным юридическим лицом. Произведенная регистрация подтверждается соответствующими юридически значимыми документами, обеспечивающими эмиссию токена. После регистрации актива токен может быть выпущен в соответствии с размером актива и депонирован на счет владельца (эмитента или, возможно, иного участника) путем установки чейнкода для этого токена во вновь созданный (или существующий) канал.

### Token operations<a name="token-operations"></a>

На этапе эксплуатации жизненного цикла токена Участникам доступен ряд действий. Ключевые действия — покупка, продажа и передача (трансфер) токенов.

Токен можно обменять на другие токены в системе через торговую площадку. Торговая площадка — это место обмена, которое предоставляет средства для размещения различных запросов на покупку и продажу токенов. Также существуют некоторые виды прямых сделок с эмитентом.

Только уполномоченный персонал организации-эмитента может подписывать транзакции.

Участники имеют уникальные адреса для каждого токена, которые можно использовать для ведения балансов токенов участников. Адрес аналогичен кошельку. Он создается в том же канале, где используется конкретный токен.

Логика операций внутреннего списания и зачисления средств на счет пользователя реализована в коде чейнкода в соответствии с документацией чейнкода и не регламентируется кодом других контрактов или Платформы.

Платформа регулирует только ввод денежных средств на счет пользователя путем авторизационной операции и возврат средств со счета по запросу пользователя.

Трансфер выполняется в рамках одного канала, не требует проведения атомарного свопа. Трансфер осуществляется путем вычитания указанной суммы из исходного баланса и прибавления ее к целевому балансу. Передача происходит в том же канале, где работает токен. Результатом перевода является изменение баланса отправителя и получателя. За операцию перевода может взиматься комиссия.

Обмен (покупка/продажа) требует взаимодействия между двумя каналами, реализованного на основе атомарного свопа (см. раздел 3.2).

Код контракта токена для платформы можно обновлять. Предполагается, что Эмитент, если обновление затрагивает логику выпуска или продажи токенов, какие-либо правила или политики, перед обновлением кода контракта публикует описание предстоящих изменений, доступных держателям, после чего изменения аналогичным образом проверяются и загружаются в канал. Код чейнкода должен обеспечивать обратную совместимость для сохранения значений балансов . Для обеспечения этих условий Платформа участвует в проверках чейнкодов.

### Token redemption<a name="token-redemption"></a>

Токен можно выкупить, когда пользователь захочет получить активы. В этом случае токен сжигается, а активы предоставляются пользователю.

## Architecture elements<a name="architecture-elements"></a>

### Channels<a name="channels"></a>

Поскольку количество пользователей и токенов, запущенных на платформе, может быть весьма велико, то наиболее перспективным методом является использование отдельного канала (channel) для каждого чейнкода токена или группы аналогичных токенов. Кроме того, ряд сервисных каналов предназначен для выполнения операций, не связанных с действиями с активами.

Каждый токен (или группа подобных токенов) функционирует в своем канале, таким образом, для каждого токена есть свое предопределенное состояние. Каналы работают независимо и транзакции в них обрабатываются параллельно. Каналы можно рассматривать как отдельные блокчейн-сети.

Каналы в Hyperledger Fabric настроены с помощью политик доступа, которые управляют доступом к ресурсам канала (чейнкодам, транзакциям и состоянию реестра), тем самым обеспечивая приватность и конфиденциальность информации в границах узлов, относяшихся к каналу. При этом Ордереры и Эндорсеры могут быть как общими с другими каналами, так и полностью изолированными. Использование канала как элемента архитектуры дает следующие преимущества:
- Уникальная гибкость — в этом случае каждый отдельный канал — это по сути отдельный блокчейн, где запущен свой чейнкод, где могут быть разные политики одобрения и консенсуса.
- Высокая масштабируемость — каналы работают полностью параллельно, и работа одного канала не влияет негативно на другой. Так как каналы могут быть запущены на отдельных Ордерерах и Эндорсерах, теоретически это означает неограниченное количество каналов.
- Расширяемость и возможность развития — чейнкоды токенов легко обновлять, а для предотвращения неуправляемости Платформа может устанавливать определенные правила и политики для аудирования, установки и обновления кода чейнкодов токенов.
- Безопасность — чейнкод каждого токена работает в отдельном канале и не взаимодействует напрямую с кодом чейнкода другого токена.

Конфиденциальность — канал со чейнкодом токена может быть запущен с использованием изолированных (с точки зрения политики доступа и ограничений прав участников консорциума) Ордереров и Эндорсеров. Это обеспечит высокий уровень конфиденциальности и сделает невозможным получение другими участниками информации об остатках и транзакциях с этим токеном.

### Atomic swap<a name="atomic-swap"></a>

Как говорилось выше, каждый токен (или группа подобных токенов) функционирует в своем канале, но для некоторых операций на платформе Atomyze необходимо выполнять межканальное взаимодействие, например, обменивать один токен на другой. Для этого должен применяться специальный механизм, обеспечивающий целостность при таких взаимодействиях. Для этого применяется стандартный механизм, называемый атомарным свопом (atomic swap).

Атомарный своп, реализованный на платформе Atomyze, осуществляется между пользователем и специализированным программным обеспечением SwapRobot, выступающим на платформе в роли «авторизованного агента». При этом своп осуществляется между кошельками одного и того же пользователя.

В атомарном свопе пользователь всегда инициирует обмен и является владельцем секретного ключа обмена. SwapRobot является «второй стороной» свопа и действует в интересах платформы.

SwapRobot проверяет, правильно ли пользователь создал первую половину атомарного обмена, а затем создает вторую половину. Точно так же после того, как пользователь раскрывает секретный ключ свопа для получения полученных средств, SwapRobot должен использовать этот ключ для получения отправленных средств.

SwapRobot не имеет по сравнению с обычным участником атомарного свопа каких-либо дополнительных преимуществ и возможностей. Пользователю не нужно доверять SwapRobot, поскольку у него есть возможность полностью проверить условия атомарного свопа с обеих сторон перед публикацией ключа.

Вслед за запуском операции перевода пользователь, как инициатор передачи токена, создает первую половину атомарного свопа и замораживает сумму, которую собирается перевести. Поскольку ключ знает только пользователь, никто (включая SwapRobot) не может взять эти токены, пока пользователь не раскроет ключ. При этом, поскольку замороженные средства будут освобождены по таймауту, пользователь уверен, что, если он никому не раскрыл свой ключ, то все токены вернутся по истечении таймаута.

После того, как SwapRobot создаст вторую половину атомарного свопа, пользователь может проверить вторую половину и убедиться, что как только он откроет ключ, отправив транзакцию в чейнкод, токены тут же будут переведены на его счет в принимающей канал и только после этого SwapRobot может использовать этот ключ для получения средств пользователя в канале отправки. SwapRobot получает доступ к ключу только после того, как пользователь успешно получит оговоренное количество токенов на свой счет во втором канале.

В любой ситуации, когда пользователь подозревает, что что-то не так, он может просто не раскрывать ключ, отказываясь от передачи, и возвращать токены по истечении времени замораживания.

### Batching<a name="batching"></a>

В качестве модели владения цифровыми активами в данном проекте была выбрана модель на основе учетной записи, имеющая следующие особенности:
• Наличие учетной записи для каждого участника сети для каждого токена.
• Транзакции содержат запросы на перевод с одного счета на другой определенного количества экземпляров токена.
• Транзакции должны пройти процедуру проверки для изменения соответствующих остатков на счетах.
• Введены дополнительные механизмы защиты от двойного списания с баланса в части добавления nonce.

Для этой модели HLF использует параллельную обработку без блокировок, предусматривающая откат в случае коллизий при чтении/записи.

Используемая Atomyze пакетная обработка (batching) предназначена для устранения ограничений, обуславливаемых реализацией токенов с помощью модели на основе учетных записей. Устраняется возможность возникновения конфликтов управления параллельным выполнением нескольких задач (MVCC), в результате которых баланс пользователя может изменяться некорректным образом. Пакетная обработка позволяет агрегировать ряд транзакций и обрабатывать их как группу. Окончательный результат затем применяется к World State (состоянию мира) .

На уровне чейнкода и World State транзакции собираются и отправляются как единое целое (массив или список) пирам. Чейнкод должен уметь обрабатывать список транзакций и выполнять их все одновременно. Результатом пакетной обработки будет последнее значение из всех транзакций, и это значение будет объективным. Когда блок будет зафиксирован, чейнкод возьмет новый пакет из базы данных World State и обработает его. Таким образом, пока блок фиксируется, чейнкод просто собирает новые транзакции и помещает их в World State. Путем точной настройки размера пакета можно достичь очень высокой производительности.

Следующий пример иллюстрирует процесс пакетной обработки. Предположим, что есть пользователи, которые инициировали последовательность транзакций по передаче токенов CC. У пользователя 1 - 80 CC, у пользователя 2 - 65 CC, а у пользователя 3 - 120 CC на балансе. Пользователь 1 отправляет 20 токенов пользователю 2, пользователь 2 отправляет 15 токенов пользователю 3. Первая транзакция приводит к изменению балансов: у пользователя 1 после завершения транзакции будет 60 CC, у пользователя 2 будет 85 CC. Затем вторая транзакция приводит к тому, что пользователь 3 имеет баланс 135 CC, а пользователь 2 — 70 CC. При пакетной обработке мы получаем конечный результат применения всех этих транзакций. Баланс пользователя 1 уменьшился на 20 CC, баланс пользователя 2 увеличился на 5 CC, а баланс пользователя 3 увеличился на 15 CC.

Основные принципы пакетной обработки следующие:
• Транзакции, которые не изменяют базу данных World State, например, информационный запрос, не сохраняются в пакетной очереди и обрабатываются обычным образом.
• Транзакции, которые изменяют World State, сохраняются в пакетной очереди. Согласно настройкам через равные промежутки времени компонент пакетной обработки принимает транзакции и обрабатывает их по следующим шагам:
- запускает процесс обмена для выполнения транзакций, требующих взаимодействия между каналами, и выполнения транзакций, не требующих взаимодействия между каналами.
- ждет ответных частей атомарных свопов.
- ожидает ключей безопасности, необходимых для закрытия свопов.

## Chaincodes<a name="chaincodes-1"></a>

### Common description<a name="common-description"></a>

Платформа Atomyze представляет две разные группы чейнкодов: чейнкод платформы и чейнкод токенов.

Чейнкод платформы отвечает за правильную работу платформы. Например, чейнкод FEE выполняет распределение комиссий, чейнкод OTF устанавливает бизнес-правила для торговли токенами на вторичном рынке и т. д.

Чейнкод токенов определяет множество токенов, которые можно использовать на платформе. В целом токены имеют довольно схожий функционал и логику. Чтобы предотвратить дублирование кода, а также обеспечить более надежную и безопасную работу токенов, для кодовой базы чейнкода была выбрана следующая структура.

Каждый токен реализован в виде чейнкода на основе стандарта Foundation. Foundation — это библиотека, реализующая базовую функциональность чейнкода, который чейнкод токенов может наследовать и расширять. Сюда относятся общие методы, необходимые для определения поведения конкретных токенов: операции, связанные с балансом, обработку атомарных свопов, пакетную обработку и проверку подписи пользователей с помощью ACL.

Foundation аналогичен стандарту ERC. Он предоставляет общие поведенческие методы и атрибуты для всех токенов, но, по сравнению с ERC, может быть легко расширен дополнительными методами и атрибутами.

В дополнение к наследованию Foundation чейнкод токена должен реализовывать интерфейс Token и, возможно, ряд других интерфейсов, таких как Transferable, для токенов, которые могут быть переданы от пользователя другому пользователю.

Основной абстракцией для чейнкода токенов является BaseToken. Он реализует общие функции токенов, такие как выпуск, передача, покупка и продажа токенов. (Описание методов BaseToken приведено ниже в разделе 4.2). BaseToken также предоставляет средства для задания метаданных токена, включая комиссию, лимиты и ставки, которые могут быть установлены эмитентом. Конкретная функциональность токена реализуется непосредственно в чейнкоде токена, который должен наследовать BaseToken. Платформа предоставляет реализации шаблонов для некоторых распространенных типов токенов. Их можно наследовать и расширять, чтобы определить конкретный токен.

С точки зрения клиента существуют следующие типы методов чейнкода: информационные запросы и пакетные транзакции. Методы информационных запросов не изменяют никаких данных и работают как поставщики данных из определенных записей реестра, например, для количества токенов на балансе пользователя. Пакетным транзакциям требуются учетные данные пользователя, и они могут изменять реестр.

### BaseContract and BaseToken<a name="basecontract-and-basetoken"></a>

BaseContract — это структура, которая реализует основные функции чейнкода, связанные с токенами. В основном он состоит из различных вспомогательных методов, упрощающих реализацию чейнкода для пользователей платформы. BaseContract также реализует атомарные свопы, которые могут использоваться как токенами, так и чейнкодами платформы. Код BaseContract приведен в Приложении 1.

BaseToken — это структура, содержащая базовые функции токена. Он наследует BaseContract и реализует некоторые обычные рабочие процессы жизненного цикла токена, такие как передача токена, покупка и т. д. Код BaseToken приведен в Приложении 2

Обе структуры, описанные выше, предоставляют разработчикам чейнкода возможность представить свои собственные функции токена или платформы. BaseContract и BaseToken также предоставляют ряд методов, которые могут вызываться извне пользователями или службами, взаимодействующими с кодами цепочки. Эти методы перечислены в таблице ниже.

Вызываемые методы BaseContract и BaseToken

| **Метод** | **Тип метода** | **Описание** | **Примененные изменения** |
| --- | --- | --- | --- |
| **BaseContract** |
| swapBegin(sender, token, contractTo, amount, hash) | Пакетная транзакция | Запускает атомарный обмен количества токенов типа токена из канала текущего контракта в канал contractTo. Объект-отправитель содержит необходимые пользовательские данные и хэш секретного ключа, блокирующего своп. | Сумма вычитается со счета отправителя. Создается запись подкачки, и ей присваивается идентификатор, равный идентификатору транзакции. SwapRobot будет использовать эту запись для создания второй части свопа в принимающем канале. |
| swapGet(swapID) | Запрос | Возвращает запись свопа с заданным swapID. Может использоваться для проверки правильности составления SwapRobot ответной части в принимающем канале. | N/A |
| swapCancel(swapID) | Пакетная транзакция | Отменяет своп с заданным идентификатором swapID. Пользователь может отменить своп только по истечении определенного тайм-аута (см.[«Атомный обмен](https://atomyze-itservices.atlassian.net/wiki/spaces/AO/pages/7864382/3.3+Atomic+Swap) »). | Замороженные токены размораживаются. Запись свопа удаляется из World State. |
| swapDone(swapID, key) Непакетная передача | Непакетная транзакция | Подтверждение свопа с заданным идентификатором swapID. Пользователь вызывает этот метод в контракте получателя, чтобы завершить процедуру атомарного свопа. key — это секретный ключ свопа, который в дальнейшем может использоваться SwapRobot в контракте отправки для передачи замороженных токенов. | key сверяется с хешем, отправленным на swapBegin. При совпадении токены переводятся на баланс пользователя. Запись сврпа удаляется из World State. Генерируется событие, содержащее ключ. |
| **BaseToken** |
| metadata() | Запрос | Возвращает метаданные токена. Метаданные включают полные и краткие имена токенов, описание базового актива, идентификатор эмитента, общую эмиссию, настройки, связанные с комиссией, и обменные курсы. | Н/Д |
| BalanceOf(address) | Query | Возвращает количество токенов на адрес пользователя. | Н/Д |
| AllowBalanceOf(address, token) | Запрос | Возвращает количество токенов типа token на адрес пользователя. | Н/Д |
| buyToken(sender, amount, currency) | Пакетная транзакция | Обмен валюты на количество нативных токенов и отправка их на баланс отправителя. Эмитент не может выступать в роли отправителя. Должен быть установлен курс валюты (см. setRate). сумма должна находиться в установленных пределах (см. setLimits). | Соответствующая сумма валюты переводится из AllowedBalance отправителя в AllowedBalance Эмитента. Количество токенов переводится с баланса Эмитента на баланс отправителя. |
| buyBack (отправитель, сумма, валюта) | Пакетная транзакция | Обменивает количество собственных токенов на валюту и отправляет полученную сумму на AllowedBalance отправителя. Эмитент не может выступать в роли отправителя. Должен быть установлен курс валюты (см. setRate). сумма должна находиться в установленных пределах (см. setLimits). | Количество токенов переводится с баланса отправителя на баланс эмитента. Соответствующая сумма валюты переводится из AllowedBalance эмитента в AllowedBalance отправителя. |
| (sender, addressTo, amount, ref) | Пакетная транзакция | передача Передает количество токенов со счета отправителя на адрес. В поле ref можно указать произвольное текстовое сообщение. | Количество токенов вычитается из счета отправителя и добавляется к addressTo. Соответствующая комиссия рассчитывается и отправляется на баланс комиссий. ref сохраняется только в журнале транзакций. |
| setRate(sender, DealType, валюта, курс) | Пакетная транзакция | Устанавливает курс обмена между собственными токенами и валютой. скорость должна быть целым числом от 1 до 10^8 включительно. rate равен 10^8, что означает конвертацию токена один в один. Только эмитент может выступать в роли отправителя. Параметр DealType выражает тип сделки (покупка, продажа и т.д.). | Метаданные токена обновлены. |
| setLimits(sender, DealType, валюта, макс, мин) | Пакетная транзакция | Устанавливает абсолютное минимальное и максимальное количество (минимальное и максимальное) нативных токенов, которые можно обменять в сделках типа сделки на токены типа валюты. Только эмитент может выступать в качестве отправителя. | Метаданные токена обновлены. |
| setFee(sender, currency, fee, floor, cap) | Пакетная транзакция | передача Устанавливает комиссию за переводы. отправитель должен иметь право устанавливать комиссию; по умолчанию это может сделать только платформа. Комиссия взимается в валюте, которая должна быть либо нативным токеном, либо токеном, который можно обменять на нативный. Fee — относительный размер комиссии от 0 до 100 000 000, где 1 000 000 единиц соответствует 1%. floor и cap — абсолютные минимальная и максимальная величины комиссии соответственно. | Метаданные токена обновлены. |
| Предсказанная комиссия(сумма) | Запрос | Возвращает комиссию за гипотетическую передачу количества токенов. | Н/Д |
| setFeeAddress(sender, address) | Пакетная транзакция | Присваивает новый адрес для сбора сборов. отправитель должен иметь права на установку платного адреса; по умолчанию это может сделать только платформа. | Метаданные токена обновлены. |
| documentAdd(document) | Непакетная транзакция | Сохраняет произвольный документ в реестр. | Составной ключ, основанный на текущей метке времени и хэше документа, задается как документ в мировом состоянии. |
| documentHistory() | Запрос | Возвращает список документов, сохраненных в реестре (включая все записи с префиксом документа | Н/Д |

## IndustrialToken<a name="industrialtoken"></a>

IndustrialToken — это класс шаблонов для токенов, представляющих один базовый актив с несколькими датами погашения. Промышленные токены сгруппированы по дате погашения. Токены одного типа с разным сроком погашения считаются разными. Промышленные токены обеспечены физическими активами, такими как металлические слитки, слитки и т. д.

Код индустриального токена вынесен из Foundation. Он свой у каждого заказчика. В Приложении 3 приведен один из вариантов.

Вызываемые методы IndustrialToken (в дополнение к BaseContract)

| **Метод** | **Тип метода** | **Описание** | **Примененные изменения** |
| --- | --- | --- | --- |
| | | | |
| metadata() | Запрос | Возвращает метаданные токена. Метаданные включают полные и краткие имена токенов, описание базового актива, идентификатор эмитента, настройки, связанные с комиссией, обменные курсы и метаданные различных групп. В метаданных группы указывается имя группы, количество выпущенных токенов, срок погашения и текстовое примечание. | Н/Д |
| AllowBalanceOf(address, token) | Запрос | См. BaseToken.allowedBalanceOf | Н/Д |
| IndustrialBalanceOf(address) | Запрос | Возвращает промышленные токены, разделенные на группы по адресам пользователей. | Н/Д |
| IndustrialBuyBack(sender, group, amount, currency) | Пакетная транзакция | Обменивает количество промышленных токенов из группы на валюту и отправляет полученную сумму на AllowedBalance отправителя. Эмитент не может выступать в качестве отправителя. Должен быть установлен курс валюты (см. setRate), сумма должна находиться в установленных пределах (см. setLimits). | Количество токенов переводится с баланса отправителя на баланс эмитента. Соответствующая сумма валюты переводится из AllowedBalance эмитента в AllowedBalance отправителя. |
| transferIndustrial(sender, addressTo, group, amount, ref) | Пакетная транзакция | Переносит количество токенов, принадлежащих группе group, со счета отправителя на адрес addressTo. В поле ref можно указать произвольное текстовое сообщение. | Количество токенов вычитается из счета отправителя и добавляется к addressTo. Соответствующая комиссия рассчитывается и отправляется на баланс комиссий, ref сохраняется только в журнале транзакций. |
| createDistribRequest(sender, args, ref) | Пакетная транзакция | Создает запрос на отправку количества токенов из определенной группы на баланс отправителя. Суммы и группы указываются в args. Раздача токенов аналогична передаче токенов, но комиссия не взимается. Запрос может быть принят или отклонен Эмитентом. В поле ref можно указать произвольное текстовое сообщение. | Создается запрос на распространение, которому присваивается идентификатор, равный идентификатору транзакции. |
| distribRequestsList() | Запрос | Возвращает список всех запросов на распространение. | Н/Д |
| acceptDistribRequest(sender, requestID, ref) | Пакетная транзакция | Передает количество токенов из разных групп на адрес в соответствии с запросом на распространение с requestID. Только эмитент может выступать в качестве отправителя. Комиссия за перевод не взимается. В поле ref можно указать произвольное текстовое сообщение. | Запрос на распространение с заданным идентификатором запроса удаляется из World State. Запрошенные токены передаются с адреса отправителя на адрес, указанный в запросе, ref сохраняется только в журнале транзакций. |
| denyDistribRequest(sender, requestID) | Пакетная транзакция | Отклоняет запрос на распространение с requestID. Только эмитент может выступать в качестве отправителя. | Запрос на распространение с заданным идентификатором запроса удаляется из World State. |
| createMCRequest (отправитель, имя\_группы, дата\_возрастания, ссылка) | Пакетная транзакция | Создает запрос на изменение даты срока действия группы имя\_группы на дату\_возрастания. В поле ref можно указать произвольное текстовое сообщение. | Создается запрос на изменение даты погашения, которому присваивается идентификатор, равный идентификатору транзакции. |
| mCRequestsList() | Запрос | Возвращает список всех запросов на изменение даты погашения. | Н/Д |
| acceptMCRequest(sender, requestID, ref) | Пакетная транзакция | Изменяет срок действия группы токенов в соответствии с запросом на изменение срока погашения с идентификатором запроса. В поле ref можно указать произвольное текстовое сообщение. Только эмитент может выступать в роли отправителя. | Запрос на изменение даты погашения с заданным идентификатором запроса удаляется из World State. Метаданные группы токенов обновлены. ref сохраняется только в журнале транзакций. |
| denyMCRequest(sender, requestID) | Пакетная транзакция | Отклоняет запрос на изменение даты погашения с идентификатором requestID. Только эмитент может выступать в качестве отправителя. | Запрос на изменение даты погашения с заданным идентификатором запроса удаляется из мирового состояния. |
| changeGroupNote(sender, groupName, note) | Пакетная транзакция | Обновляет запись для группы токенов с указанным groupName. Только эмитент может выступать в качестве отправителя. | Метаданные группы groupName обновлены. |
| createRedeemRequest(sender, groupName, amount, ref) | Пакетная транзакция | Создает запрос на погашение количества токенов из группы groupName. В поле ref можно указать произвольное текстовое сообщение. | Создается запрос на погашение, и ему присваивается идентификатор, равный идентификатору tx. сумма замораживается на балансе отправителя. |
| redeemRequestsList() | Запрос | Возвращает список всех запросов на погашение. | Н/Д |
| acceptRedeemRequest(sender, requestID, amount, ref) | Пакетная транзакция | Принимает погашение количества токенов в соответствии с запросом на погашение requestID. Только эмитент может выступать в качестве отправителя. В поле ref можно указать произвольное текстовое сообщение. В результате процесса выкупа пользователь, указанный в запросе, становится владельцем базового физического актива. | Запрос погашения с заданным идентификатором запроса удаляется из World State. Количество токенов вычитается из общей эмиссии группы. Оставшиеся замороженные токены размораживаются. |
| denyRedeemRequest(sender, requestID) | Пакетная транзакция | Отклоняет запрос на погашение с requestID. Только эмитент может выступать в качестве отправителя. | Запрос погашения с заданным идентификатором запроса удаляется из World State. Замороженные токены размораживаются. |
| setRate(sender, dealType, currency, rate) | Пакетная транзакция | См. BaseToken.setRate | См. BaseToken.setRate |
| setLimits(sender, dealType, currency, min, max) | Пакетная транзакция | См. BaseToken.setLimits | См. BaseToken.setLimits |
| setFee(sender, currency, fee, floor, cap) | Пакетная транзакция | См. BaseToken.setFee | См. BaseToken.setFee |
| predictFee(amount) | Запрос | См. BaseToken.predictFee | См. BaseToken.predictFee |
| setFeeAddress(sender, address) | Пакетная транзакция | См. BaseToken.setFeeAddress | См. BaseToken.setFeeAddress |
| addDocs(sender, rawDocs) | Пакетная транзакция | Сохраняет ряд документов в реестре. Описание документа состоит из идентификатора и хэша. Аргумент rawDocs содержит список описаний. Только эмитент может выступать в качестве отправителя. | Составной ключ, основанный на идентификаторе документа с префиксом it\_doc , устанавливается на соответствующее описание документа в World State. |
| deleteDoc(sender, docID) | Пакетная транзакция | Удаляет документ с указанным docID из World State. Только эмитент может выступать в качестве отправителя. | Документ с данным docID удаляется из World State. |
| documentList() | Запрос | Возвращает список документов, сохраненных в реестре (включая все записи с префиксом it\_doc ). | Н/Д |

## Appendix 1. BaseContract code<a name="appendix-1-basecontract-code"></a>

```
package core
import ("encoding/hex"
    "log"
    "sort"
    "github.com/hyperledger/fabric-chaincode-go/shim"
    "gitlab.n-t.io/core/library/go/foundation/core/types"
    big "gitlab.n-t.io/core/library/go/foundation/golang_math_big"
    pb "gitlab.n-t.io/core/library/go/foundation/proto")
type BaseContract struct {
    id string
    stub shim.ChaincodeStubInterface
    methods[] string
    allowedMspID string
    atomyzeSKI[] byte
    initArgs[] string
}

func(bc * BaseContract) baseContractInit(cc BaseContractInterface) {
    bc.id = cc.GetID()
}

func(bc * BaseContract) GetStub() shim.ChaincodeStubInterface {
    return bc.stub
}

func(bc * BaseContract) GetCreatorSKI() string {
    stub, ok: = bc.stub.( * batchTxStub)
    if ok {
        return stub.creatorSKI
    }
    log.Println("Couldn't get creatorSKI because stub is not batchTxStub")
    return ""
}

func(bc * BaseContract) GetMethods()[] string {
    return bc.methods
}

func(bc * BaseContract) addMethod(mm string) {
    bc.methods = append(bc.methods, mm)
    sort.Strings(bc.methods)
}

func(bc * BaseContract) setStubAndInitArgs(stub shim.ChaincodeStubInterface, allowedMspID string, atomyzeSKI[] byte, args[] string) {
    bc.stub = stub
    bc.allowedMspID = allowedMspID
    bc.atomyzeSKI = atomyzeSKI
    bc.initArgs = args
}

func(bc * BaseContract) GetAllowedMspID() string {
    return bc.allowedMspID
}

func(bc * BaseContract) GetAtomyzeSKI()[] byte {
    return bc.atomyzeSKI
}

func(bc * BaseContract) GetInitArg(idx int) string {
    return bc.initArgs[idx]
}

func(bc * BaseContract) GetInitArgsLen() int {
    return len(bc.initArgs)
}

func(bc * BaseContract) QueryGetNonce(owner types.Address)(string, error) { //nolint:govet
    prefix: = hex.EncodeToString([] byte {
        byte(StateKeyNonce)
    })
    key,
    err: = bc.stub.CreateCompositeKey(prefix, [] string {
        owner.String()
    })
    if err != nil {
        return "", err
    }
    data,
    err: = bc.stub.GetState(key)
    if err != nil {
        return "", err
    }
    existed: = new(big.Int).SetBytes(data)
    return existed.String(),
    nil
}

type BaseContractInterface interface {
    GetStub() shim.ChaincodeStubInterface
    addMethod(string)
    setStubAndInitArgs(shim.ChaincodeStubInterface, string, [] byte, [] string)
    GetID() string
    baseContractInit(BaseContractInterface)
    TokenBalanceTransfer(from types.Address, to types.Address, amount * big.Int, reason string) error
    AllowedBalanceTransfer(token string, from types.Address, to types.Address, amount * big.Int, reason string) error
    TokenBalanceGet(address types.Address)( * big.Int, error)
    TokenBalanceAdd(address types.Address, amount * big.Int, reason string) error
    TokenBalanceSub(address types.Address, amount * big.Int, reason string) error
    AllowedBalanceGet(token string, address types.Address)( * big.Int, error)
    AllowedBalanceAdd(token string, address types.Address, amount * big.Int, reason string) error
    AllowedBalanceSub(token string, address types.Address, amount * big.Int, reason string) error
    AllowedBalanceGetAll(address types.Address)(map[string] string, error)
    tokenBalanceAdd(address types.Address, amount * big.Int, token string) error
    IndustrialBalanceGet(address types.Address)(map[string] string, error)
    IndustrialBalanceTransfer(token string, from types.Address, to types.Address, amount * big.Int, reason string) error
    IndustrialBalanceAdd(token string, address types.Address, amount * big.Int, reason string) error
    IndustrialBalanceSub(token string, address types.Address, amount * big.Int, reason string) error
    AllowedIndustrialBalanceAdd(address types.Address, industrialAssets[] * pb.Asset, reason string) error
    AllowedIndustrialBalanceSub(address types.Address, industrialAssets[] * pb.Asset, reason string) error
    AllowedIndustrialBalanceTransfer(from types.Address, to types.Address, industrialAssets[] * pb.Asset, reason string) error
}
```

## Appendix 2. BaseToken code<a name="appendix-2-basetoken-code"></a>

```
package token
import ("errors"
    pb "github.com/golang/protobuf/proto" //nolint:staticcheck
    "gitlab.n-t.io/core/library/go/foundation/core"
    "gitlab.n-t.io/core/library/go/foundation/core/types"
    big "gitlab.n-t.io/core/library/go/foundation/golang math big"
    "gitlab.n-t.io/core/library/go/foundation/proto")
const (FeeSetterArgPos = 1 FeeAddressSetterArgPos = 2 metadataKey = "tokenMetadata")
type Tokener interface {
    core.BaseContractInterface
    EmissionAdd( * big.Int) error
    EmissionSub( * big.Int) error
    GetRateAndLimits(string, string)( * proto.TokenRate, bool, error)
}

type BaseToken struct {
    core.BaseContract
    Name string
    Symbol string
    Decimals uint
    UnderlyingAsset string
    config * proto.Token
}

func(bt * BaseToken) Issuer() types.Address {
    addr, err: = types.AddrFromBase58Check(bt.GetInitArg(0))
    if err != nil {
        panic(err)
    }
    return addr //nolint:govet
}

func(bt * BaseToken) FeeSetter() types.Address {
    addr, err: = types.AddrFromBase58Check(bt.GetInitArg(FeeSetterArgPos))
    if err != nil {
        panic(err)
    }
    return addr //nolint:govet
}

func(bt * BaseToken) FeeAddressSetter() types.Address {
    addr, err: = types.AddrFromBase58Check(bt.GetInitArg(FeeAddressSetterArgPos))
    if err != nil {
        panic(err)
    }
    return addr //nolint:govet
}

func(bt * BaseToken) GetID() string {
    return bt.Symbol
}

func(bt * BaseToken) loadConfigUnlessLoaded() error {
    data, err: = bt.GetStub().GetState(metadataKey)
    if err != nil {
        return err
    }
    if bt.config == nil {
        bt.config = & proto.Token {}
    }
    if len(data) == 0 {
        return nil
    }
    return pb.Unmarshal(data, bt.config)
}

func(bt * BaseToken) saveConfig() error {
    data, err: = pb.Marshal(bt.config)
    if err != nil {
        return err
    }
    return bt.GetStub().PutState(metadataKey, data)
}

func(bt * BaseToken) EmissionAdd(amount * big.Int) error {
    if err: = bt.loadConfigUnlessLoaded();
    err != nil {
        return err
    }
    if bt.config.TotalEmission == nil {
        bt.config.TotalEmission = new(big.Int).Bytes()
    }
    bt.config.TotalEmission = new(big.Int).Add(new(big.Int).SetBytes(bt.config.TotalEmission), amount).Bytes()
    return bt.saveConfig()
}

func(bt * BaseToken) EmissionSub(amount * big.Int) error {
    if err: = bt.loadConfigUnlessLoaded();
    err != nil {
        return err
    }
    if bt.config.TotalEmission == nil {
        bt.config.TotalEmission = new(big.Int).Bytes()
    }
    if new(big.Int).SetBytes(bt.config.TotalEmission).Cmp(amount)\ < 0 {
        return errors.New("emission can't become negative")
    }
    bt.config.TotalEmission = new(big.Int).Sub(new(big.Int).SetBytes(bt.config.TotalEmission), amount).Bytes()
    return bt.saveConfig()
}

func(bt * BaseToken) setFee(currency string, fee * big.Int, floor * big.Int, cap * big.Int) error {
    if err: = bt.loadConfigUnlessLoaded();
    err != nil {
        return err
    }
    if bt.config.Fee == nil {
        bt.config.Fee = & proto.TokenFee {}
    }
    if currency == bt.Symbol {
        bt.config.Fee.Currency = currency
        bt.config.Fee.Fee = fee.Bytes()
        bt.config.Fee.Floor = floor.Bytes()
        bt.config.Fee.Cap = cap.Bytes()
        return bt.saveConfig()
    }
    for, rate: = range bt.config.Rates {
        if rate.Currency == currency {
            bt.config.Fee.Currency = currency
            bt.config.Fee.Fee = fee.Bytes()
            bt.config.Fee.Floor = floor.Bytes()
            bt.config.Fee.Cap = cap.Bytes()
            return bt.saveConfig()
        }
    }
    return errors.New("unknown currency")
}

func(bt * BaseToken) GetRateAndLimits(dealType string, currency string)( * proto.TokenRate, bool, error) {
    if err: = bt.loadConfigUnlessLoaded();
    err != nil {
        return nil, false, err
    }
    for, r: = range bt.config.Rates {
        if r.DealType == dealType && r.Currency == currency {
            return r, true, nil
        }
    }
    return &proto.TokenRate {}, false, nil
}
```

## Appendix 3. IndustrialToken code<a name="appendix-3-industrialtoken-code"></a>

```
package token
import ("errors"
    "strings"
    "time"
    "gitlab.n-t.io/atmz/foundation/core"
    "gitlab.n-t.io/atmz/foundation/core/types"
    "gitlab.n-t.io/atmz/foundation/golang-math-big"
    "gitlab.n-t.io/atmz/foundation/proto"
    pb "github.com/golang/protobuf/proto")
// Group base struct
type Group struct {
    ID string
    Emission uint64
    Maturity string
    Note string
}

// ITInterface - base method for an industrial token prototype
type ITInterface interface {
    core.BaseContractInterface
    GetRateAndLimits(string, string)( * proto.TokenRate, bool, error)
}

// IndustrialToken base struct
type IndustrialToken struct {
    core.BaseContract
    Name string
    Symbol string
    Decimals uint
    UnderlyingAsset string
    DeliveryForm string
    UnitOfMeasure string
    TokensForUnit string
    PaymentTerms string
    Price string
    config * proto.Industrial
}

// GetID returns token id
func(it * IndustrialToken) GetID() string {
    return it.Symbol
}
func(it * IndustrialToken) Issuer() types.Address {
    addr, err: = types.AddrFromBase58Check(it.GetInitArg(0))
    if err != nil {
        panic(err)
    }
    return addr
}

func(it * IndustrialToken) FeeSetter() types.Address {
    addr, err: = types.AddrFromBase58Check(it.GetInitArg(1))
    if err != nil {
        panic(err)
    }
    return addr
}

func(it * IndustrialToken) FeeAddressSetter() types.Address {
    addr, err: = types.AddrFromBase58Check(it.GetInitArg(2))
    if err != nil {
        panic(err)
    }
    return addr
}

func(it * IndustrialToken) loadConfigUnlessLoaded() error {
    data, err: = it.GetStub().GetState("tokenMetadata")
    if err != nil {
        return err
    }
    if it.config == nil {
        it.config = & proto.Industrial {}
    }
    if len(data) == 0 {
        return nil
    }
    return pb.Unmarshal(data, it.config)
}

func(it * IndustrialToken) saveConfig() error {
    data, err: = pb.Marshal(it.config)
    if err != nil {
        return err
    }
    return it.GetStub().PutState("tokenMetadata", data)
}

func(it * IndustrialToken) setFee(currency string, fee * big.Int, floor * big.Int, cap * big.Int) error {
    if err: = it.loadConfigUnlessLoaded();
    err != nil {
        return err
    }
    if it.config.Fee == nil {
        it.config.Fee = & proto.TokenFee {}
    }
    if currency == it.Symbol {
        it.config.Fee.Currency = currency
        it.config.Fee.Fee = fee.Bytes()
        it.config.Fee.Floor = floor.Bytes()
        it.config.Fee.Cap = cap.Bytes()
        return it.saveConfig()
    }
    for, rate: = range it.config.Rates {
        if rate.Currency == currency {
            it.config.Fee.Currency = currency
            it.config.Fee.Fee = fee.Bytes()
            it.config.Fee.Floor = floor.Bytes()
            it.config.Fee.Cap = cap.Bytes()
            return it.saveConfig()
        }
    }
    return errors.New("unknown currency")
}

// GetRateAndLimits returns token rate and limits from metadata
func(it * IndustrialToken) GetRateAndLimits(dealType string, currency string)( * proto.TokenRate, bool, error) {
    if err: = it.loadConfigUnlessLoaded();
    err != nil {
        return nil, false, err
    }
    for, r: = range it.config.Rates {
        if r.DealType == dealType && r.Currency == currency {
            return r, true, nil
        }
    }
    return &proto.TokenRate {}, false, nil
}

// Initialize - token initialization
func(it * IndustrialToken) Initialize(groups[] Group) error {
    if err: = it.loadConfigUnlessLoaded();
    err != nil {
        return err
    }
    if it.config.Initialized {
        return nil
    }
    var industrialGroups[] * proto.IndustrialGroup
    for, group: = range groups {
        if strings.Contains(group.ID, ",") {
            return errors.New("wrong group name")
        }
        maturity, err: = time.Parse(timeFormat, group.Maturity)
        if err != nil {
            return err
        }
        industrialGroups = append(industrialGroups, & proto.IndustrialGroup {
            Id: group.ID,
            Maturity: maturity.Unix(),
            Emission: new(big.Int).SetUint64(group.Emission).Bytes(),
            Note: group.Note,
        })
    }
    it.config.Groups = industrialGroups
    it.config.Initialized = true
    for, x: = range industrialGroups {
        if err: = it.IndustrialBalanceAdd(it.Symbol + " " + x.Id, it.Issuer(), new(big.Int).SetBytes(x.Emission), "initial emit");
        err != nil {
            return err
        }
    }
    return it.saveConfig()
}
```
