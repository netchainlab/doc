# Батчинг атомайз
Created Четверг 13 апреля 2023

Предлагается к рассмотрению жизненный цикл транзакции на платформе Атомайз, которая в свою очередь базируется на проекте Hyper ledger fabric. Мы рассмотрим в чем данный цикл отличается от базового флоу транзакции HLF, какие и как решает проблемы.

Основной слайд - диаграмма сиквенс.
+диаграмма

## Общий флоу транзакции клиента HLF
На нашей диаграмме рассмотрим часть, относящуюся к базовому флоу HLF .
1. Клиент создает transaction proposal и рассылает их на endorsment peers согласно endorsment policy данного чейнкода.
2. исполнение transaction proposal на endorsers на основе собственного state, формирование ответа в виде R/W-SET. Read set  включает версию прочитанного ключа, write set содержит новое значение.
3. клиент получает подписанный ответ endorser - proposal response
4. клиент сравнивает  ответы и в случае выполнения endorsment policy, формирует транзакцию с ответами ендорсеров и отсылает её на ордеринг.
5. Сервис ордеринга отвечает клиенту после того как транзакция принимается для включения в очередной блок.
6. Ордеринг выпуск блока согласно настройкам - по таймауту или по достаточному количеству полученных транзакций.
7. Броадкаст блока на все пиры по протоколу Gossip.
8. Валидация блока на пирах.
+флоу транзакции клиента


## Валидация блока на коммитмент пире.
+типы пиров
Пиры или узлы HLF - это объект сети, которые используются для поддержания распределенной базы данных (ledger), могут читать и писать в state и лог. Commitment peer - узел, основной задачей которого является поддержание БД и структуры блокчейн. Получает, верифицирует и сохраняет блоки.

Порядок обработки блока на коммитмент пире:
1. получение блока от ордеринга по протоколу gossip.
2. проверка подписи ордереров, участвующих в создании блока.
3. Каждая транзакция блока декодируется и проходит синтаксическую проверку.
4. VSCC (системный чейнкод - Validation System Chaincode) проверяет  выполнение условий endorsment policy указанного для чейнкода транзакции. В случае если не выполняется, транзакция помечается как инвалидная.
+vscc
5. MVCC (не чейнкод) - Multiversion Concurrency Control; проверка версии ключей: проверка что версия ключей, прочитанных на этапе ендорсмента совпадает с текущим состоянием данного пира.  Read set каждой транзакции заново вычитывается из state (БД) и сравнивается с read set на этапе ендорсмента. Если значения ВЕРСИЙ (не значений) различные, то это означает, что какая-то транзакция, более ранняя в данном блоке или в предыдущих блокахуже изменила те же ключи и таким образом проверяемая транзакция не может быть достоверной, помечается как недействительная или инвалидная
+mvcc
6. Коммит блока;
6.1 запись всех транзакций в Log леджера, вне зависимости от их валидности.
6.2 запись всех write set от валидных транзакций в state.
6.3 обновление history database - какие ключи были изменены в данном блоке и какими транзакциями.
+commit

### из интересного - проблема времени в логике ченкода с учетом флоу транзакции, при существующем порядке валидации на этапе обработки блока.
Возможна задержка клиентом отправки транзакции на ордеринг, что может привести к логическим ошибкам, в случае если логика чейнкода связана с проверкой времени. Как пример - чейнкод проверяет что транзакция должна разместиться не позднее чем время Х - данная проверка может быть дискредитирована, если на SDK будет произведена задержка отправки транзакции на ордеринг.

## Проблема
Описание проблемы - из вышесказанного, становится очевидно, что в при реализации account based модели, могут быть проблемы в случае высокой нагрузки на систему. Account based можель наиболее рапространена и не требует больших затрат на разработку новой логики чейнкода, поэтому выбор пал на этот вариант. Данная модель широко использует естественные записи информации в БД, перечисляя объекты и их значения соответственно прямой логической связке. Так например баланс пользователя в токенах gold записывается явно ALICE_GOLD => 100. В случае если данный пользователь ведет активную работу со своим кошельком, то могут быть проблемы на уровне MVCC.

## Решение
Атомайз решает данную проблему через пакетную обработку данных (batching).

1. Клиент отправляет транзакцию на исполнение
2. Транзакция проходит первичный ендорсмент в результате чего создается запись в стейте с уникальным ключом и поступившими из транзакции данными. На данном этапе не производится никакой обработки данных и MVCC не возможен. Таким образом формируется преимадж (preimage) транзакций в стейте канала, количество которых может быть сколь угодно большим.
(ПОИСКАТЬ КОД В ФАУНДЕЙШН, ФОРМИРУЮЩИЙ ПРЕИМАДЖИ В СТЕЙТЕ)

3. Специальный сервис (robot) мониторит наличие необработанных преимаджей, создает и публикует транзакцию батчинга, в которой перечисляет набор уникальных ключей, под которыми записаны преимаджи в стейт. При этом сохраняет их порядок поступления.
(ПОКАЗАТЬ КОД РОБОТА?) ПОКАЗАТЬ КОД ИТЕРАЦИИ БАТЧА В ФАУНДЕЙШЕНЕ

4. Ендорсеры обрабатывают батч транзакцию как единое целое, циклически читая преимаджи из стейта и передавая параметры транзакции на обработку, а так же кешируя прочитанные и измененные ключи стейта. Таким образом формируется общий результат, который не будет иметь коллизий чтения и записи.
![batching_sequence](/doc/uploads/batching_sequence.png)
| <b>Схема прохождения транзакции в Атомайз</b>|
